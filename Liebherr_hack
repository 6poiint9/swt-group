Notes:
Command => head -n 500 df_history_2025-11-03.csv > history_edit.csv


--- Datensätze ---
## df_history:
Nutzen: zum training des Modells
=> voraussichtliche Fertigstellungstermine von Fertigungsaufträgen realistisch prognostizieren 
- beinhaltet abgearbeitete sowie aktuell laufende Fertigungsaufträge
=> von den 3 witchtigsten Bauteilen:
- Steuerventilmodul, Schwenkzylinder und Dämpfungseinheit. 
Jeder auftrag besteht aus -> durchlaufenen Arbeitsschritten (AFO)

## df_IDs_for_eval
- Liste von offenen auftrags IDs
=> für diese soll Fertigstellungstermin prognostiziert werden soll.

## eval_public und eval_private
- unterschiedliche Aufträge
=> wichtig für Aussage aber nicht für training
Enthält:
- Features für die Aufträge, die ihr vorhersagen müsst


--- Generell ---
- Modell wird mit ## df_history trainiert!
- AFO start ist ab Info
-  "just-in-time" Ansatz => Aufträge werden so eingeplant, zu Zeitpunkt fertig werden, den der Kunde bei der Bestellung angegeben hat, 
nicht wann sie bestellt wurden.


--- Bereinigen ---
Raus:
- alles vor 01.01.2014
- alles nach 01.03.2024 weg

Prozess:
IST_START und IST_ENDE
=> AFO_DAUER in stunden wird addiert 

AFO Fertigungsuftrag-komplett:

Wochentags Maske:
import pandas as pd
from pandas.tseries.offsets import CustomBusinessHour

# 1. Definition der Produktionszeit (MO-FR, 07:00 - 15:00)
# Wir definieren KEINE Feiertage, da laut Aufgabe an Feiertagen gearbeitet wird.
production_offset = CustomBusinessHour(
    start='07:00',
    end='15:00',
    weekmask='Mon Tue Wed Thu Fri' 
)

def calculate_end_date(start_dt, duration_hours):
    """
    Addiert eine Dauer in Stunden auf ein Startdatum unter Berücksichtigung
    der Produktionszeiten (Mo-Fr 07-15 Uhr).
    """
    # Sicherheitscheck: Valide Datetime?
    if pd.isna(start_dt):
        return pd.NaT
    
    # CustomBusinessHour rechnet in 'Business Hours'.
    # Wenn wir floats haben (z.B. 2.5 Stunden), müssen wir das beachten.
    # Leider unterstützt CustomBusinessHour nur Integer-Multiplikation direkt gut mit +
    # Workaround für Floats: Wir konvertieren in Minuten
    
    duration_minutes = int(round(duration_hours * 60))
    
    # Wir addieren Minuten. Leider ist CustomBusinessHour etwas zickig mit Minuten-Offsets.
    # Besserer Weg laut Pandas Docs für genaue Zeit:
    # Wir nutzen den Offset, um Tage zu springen, aber wir müssen die 'Restminuten'
    # innerhalb des Offsets handhaben.
    
    # Einfachste Approximation, die meistens genau genug ist für ML:
    # Wir teilen die Stunden in BusinessHours auf.
    
    return start_dt + (duration_hours * production_offset)


=> smartere sachen
-> was erzeugt Varianz => 






